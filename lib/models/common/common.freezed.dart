// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'common.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

Metadata _$MetadataFromJson(Map<String, dynamic> json) {
  return _Metadata.fromJson(json);
}

/// @nodoc
class _$MetadataTearOff {
  const _$MetadataTearOff();

  _Metadata call(
      {String? address,
      String? kind,
      String? owner,
      String? alias,
      String? description,
      String? logo,
      String? site,
      String? support,
      String? email,
      String? twitter,
      String? telegram,
      String? discord,
      String? reddit,
      String? slack,
      String? riot,
      String? github,
      String? instagram,
      String? facebook}) {
    return _Metadata(
      address: address,
      kind: kind,
      owner: owner,
      alias: alias,
      description: description,
      logo: logo,
      site: site,
      support: support,
      email: email,
      twitter: twitter,
      telegram: telegram,
      discord: discord,
      reddit: reddit,
      slack: slack,
      riot: riot,
      github: github,
      instagram: instagram,
      facebook: facebook,
    );
  }

  Metadata fromJson(Map<String, Object> json) {
    return Metadata.fromJson(json);
  }
}

/// @nodoc
const $Metadata = _$MetadataTearOff();

/// @nodoc
mixin _$Metadata {
  String? get address => throw _privateConstructorUsedError;
  String? get kind => throw _privateConstructorUsedError;
  String? get owner => throw _privateConstructorUsedError;
  String? get alias => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  String? get logo => throw _privateConstructorUsedError;
  String? get site => throw _privateConstructorUsedError;
  String? get support => throw _privateConstructorUsedError;
  String? get email => throw _privateConstructorUsedError;
  String? get twitter => throw _privateConstructorUsedError;
  String? get telegram => throw _privateConstructorUsedError;
  String? get discord => throw _privateConstructorUsedError;
  String? get reddit => throw _privateConstructorUsedError;
  String? get slack => throw _privateConstructorUsedError;
  String? get riot => throw _privateConstructorUsedError;
  String? get github => throw _privateConstructorUsedError;
  String? get instagram => throw _privateConstructorUsedError;
  String? get facebook => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MetadataCopyWith<Metadata> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MetadataCopyWith<$Res> {
  factory $MetadataCopyWith(Metadata value, $Res Function(Metadata) then) =
      _$MetadataCopyWithImpl<$Res>;
  $Res call(
      {String? address,
      String? kind,
      String? owner,
      String? alias,
      String? description,
      String? logo,
      String? site,
      String? support,
      String? email,
      String? twitter,
      String? telegram,
      String? discord,
      String? reddit,
      String? slack,
      String? riot,
      String? github,
      String? instagram,
      String? facebook});
}

/// @nodoc
class _$MetadataCopyWithImpl<$Res> implements $MetadataCopyWith<$Res> {
  _$MetadataCopyWithImpl(this._value, this._then);

  final Metadata _value;
  // ignore: unused_field
  final $Res Function(Metadata) _then;

  @override
  $Res call({
    Object? address = freezed,
    Object? kind = freezed,
    Object? owner = freezed,
    Object? alias = freezed,
    Object? description = freezed,
    Object? logo = freezed,
    Object? site = freezed,
    Object? support = freezed,
    Object? email = freezed,
    Object? twitter = freezed,
    Object? telegram = freezed,
    Object? discord = freezed,
    Object? reddit = freezed,
    Object? slack = freezed,
    Object? riot = freezed,
    Object? github = freezed,
    Object? instagram = freezed,
    Object? facebook = freezed,
  }) {
    return _then(_value.copyWith(
      address: address == freezed
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String?,
      kind: kind == freezed
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as String?,
      owner: owner == freezed
          ? _value.owner
          : owner // ignore: cast_nullable_to_non_nullable
              as String?,
      alias: alias == freezed
          ? _value.alias
          : alias // ignore: cast_nullable_to_non_nullable
              as String?,
      description: description == freezed
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      logo: logo == freezed
          ? _value.logo
          : logo // ignore: cast_nullable_to_non_nullable
              as String?,
      site: site == freezed
          ? _value.site
          : site // ignore: cast_nullable_to_non_nullable
              as String?,
      support: support == freezed
          ? _value.support
          : support // ignore: cast_nullable_to_non_nullable
              as String?,
      email: email == freezed
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      twitter: twitter == freezed
          ? _value.twitter
          : twitter // ignore: cast_nullable_to_non_nullable
              as String?,
      telegram: telegram == freezed
          ? _value.telegram
          : telegram // ignore: cast_nullable_to_non_nullable
              as String?,
      discord: discord == freezed
          ? _value.discord
          : discord // ignore: cast_nullable_to_non_nullable
              as String?,
      reddit: reddit == freezed
          ? _value.reddit
          : reddit // ignore: cast_nullable_to_non_nullable
              as String?,
      slack: slack == freezed
          ? _value.slack
          : slack // ignore: cast_nullable_to_non_nullable
              as String?,
      riot: riot == freezed
          ? _value.riot
          : riot // ignore: cast_nullable_to_non_nullable
              as String?,
      github: github == freezed
          ? _value.github
          : github // ignore: cast_nullable_to_non_nullable
              as String?,
      instagram: instagram == freezed
          ? _value.instagram
          : instagram // ignore: cast_nullable_to_non_nullable
              as String?,
      facebook: facebook == freezed
          ? _value.facebook
          : facebook // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$MetadataCopyWith<$Res> implements $MetadataCopyWith<$Res> {
  factory _$MetadataCopyWith(_Metadata value, $Res Function(_Metadata) then) =
      __$MetadataCopyWithImpl<$Res>;
  @override
  $Res call(
      {String? address,
      String? kind,
      String? owner,
      String? alias,
      String? description,
      String? logo,
      String? site,
      String? support,
      String? email,
      String? twitter,
      String? telegram,
      String? discord,
      String? reddit,
      String? slack,
      String? riot,
      String? github,
      String? instagram,
      String? facebook});
}

/// @nodoc
class __$MetadataCopyWithImpl<$Res> extends _$MetadataCopyWithImpl<$Res>
    implements _$MetadataCopyWith<$Res> {
  __$MetadataCopyWithImpl(_Metadata _value, $Res Function(_Metadata) _then)
      : super(_value, (v) => _then(v as _Metadata));

  @override
  _Metadata get _value => super._value as _Metadata;

  @override
  $Res call({
    Object? address = freezed,
    Object? kind = freezed,
    Object? owner = freezed,
    Object? alias = freezed,
    Object? description = freezed,
    Object? logo = freezed,
    Object? site = freezed,
    Object? support = freezed,
    Object? email = freezed,
    Object? twitter = freezed,
    Object? telegram = freezed,
    Object? discord = freezed,
    Object? reddit = freezed,
    Object? slack = freezed,
    Object? riot = freezed,
    Object? github = freezed,
    Object? instagram = freezed,
    Object? facebook = freezed,
  }) {
    return _then(_Metadata(
      address: address == freezed
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String?,
      kind: kind == freezed
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as String?,
      owner: owner == freezed
          ? _value.owner
          : owner // ignore: cast_nullable_to_non_nullable
              as String?,
      alias: alias == freezed
          ? _value.alias
          : alias // ignore: cast_nullable_to_non_nullable
              as String?,
      description: description == freezed
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      logo: logo == freezed
          ? _value.logo
          : logo // ignore: cast_nullable_to_non_nullable
              as String?,
      site: site == freezed
          ? _value.site
          : site // ignore: cast_nullable_to_non_nullable
              as String?,
      support: support == freezed
          ? _value.support
          : support // ignore: cast_nullable_to_non_nullable
              as String?,
      email: email == freezed
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      twitter: twitter == freezed
          ? _value.twitter
          : twitter // ignore: cast_nullable_to_non_nullable
              as String?,
      telegram: telegram == freezed
          ? _value.telegram
          : telegram // ignore: cast_nullable_to_non_nullable
              as String?,
      discord: discord == freezed
          ? _value.discord
          : discord // ignore: cast_nullable_to_non_nullable
              as String?,
      reddit: reddit == freezed
          ? _value.reddit
          : reddit // ignore: cast_nullable_to_non_nullable
              as String?,
      slack: slack == freezed
          ? _value.slack
          : slack // ignore: cast_nullable_to_non_nullable
              as String?,
      riot: riot == freezed
          ? _value.riot
          : riot // ignore: cast_nullable_to_non_nullable
              as String?,
      github: github == freezed
          ? _value.github
          : github // ignore: cast_nullable_to_non_nullable
              as String?,
      instagram: instagram == freezed
          ? _value.instagram
          : instagram // ignore: cast_nullable_to_non_nullable
              as String?,
      facebook: facebook == freezed
          ? _value.facebook
          : facebook // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Metadata implements _Metadata {
  const _$_Metadata(
      {this.address,
      this.kind,
      this.owner,
      this.alias,
      this.description,
      this.logo,
      this.site,
      this.support,
      this.email,
      this.twitter,
      this.telegram,
      this.discord,
      this.reddit,
      this.slack,
      this.riot,
      this.github,
      this.instagram,
      this.facebook});

  factory _$_Metadata.fromJson(Map<String, dynamic> json) =>
      _$$_MetadataFromJson(json);

  @override
  final String? address;
  @override
  final String? kind;
  @override
  final String? owner;
  @override
  final String? alias;
  @override
  final String? description;
  @override
  final String? logo;
  @override
  final String? site;
  @override
  final String? support;
  @override
  final String? email;
  @override
  final String? twitter;
  @override
  final String? telegram;
  @override
  final String? discord;
  @override
  final String? reddit;
  @override
  final String? slack;
  @override
  final String? riot;
  @override
  final String? github;
  @override
  final String? instagram;
  @override
  final String? facebook;

  @override
  String toString() {
    return 'Metadata(address: $address, kind: $kind, owner: $owner, alias: $alias, description: $description, logo: $logo, site: $site, support: $support, email: $email, twitter: $twitter, telegram: $telegram, discord: $discord, reddit: $reddit, slack: $slack, riot: $riot, github: $github, instagram: $instagram, facebook: $facebook)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Metadata &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.kind, kind) ||
                const DeepCollectionEquality().equals(other.kind, kind)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.alias, alias) ||
                const DeepCollectionEquality().equals(other.alias, alias)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.logo, logo) ||
                const DeepCollectionEquality().equals(other.logo, logo)) &&
            (identical(other.site, site) ||
                const DeepCollectionEquality().equals(other.site, site)) &&
            (identical(other.support, support) ||
                const DeepCollectionEquality()
                    .equals(other.support, support)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.twitter, twitter) ||
                const DeepCollectionEquality()
                    .equals(other.twitter, twitter)) &&
            (identical(other.telegram, telegram) ||
                const DeepCollectionEquality()
                    .equals(other.telegram, telegram)) &&
            (identical(other.discord, discord) ||
                const DeepCollectionEquality()
                    .equals(other.discord, discord)) &&
            (identical(other.reddit, reddit) ||
                const DeepCollectionEquality().equals(other.reddit, reddit)) &&
            (identical(other.slack, slack) ||
                const DeepCollectionEquality().equals(other.slack, slack)) &&
            (identical(other.riot, riot) ||
                const DeepCollectionEquality().equals(other.riot, riot)) &&
            (identical(other.github, github) ||
                const DeepCollectionEquality().equals(other.github, github)) &&
            (identical(other.instagram, instagram) ||
                const DeepCollectionEquality()
                    .equals(other.instagram, instagram)) &&
            (identical(other.facebook, facebook) ||
                const DeepCollectionEquality()
                    .equals(other.facebook, facebook)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(kind) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(alias) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(logo) ^
      const DeepCollectionEquality().hash(site) ^
      const DeepCollectionEquality().hash(support) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(twitter) ^
      const DeepCollectionEquality().hash(telegram) ^
      const DeepCollectionEquality().hash(discord) ^
      const DeepCollectionEquality().hash(reddit) ^
      const DeepCollectionEquality().hash(slack) ^
      const DeepCollectionEquality().hash(riot) ^
      const DeepCollectionEquality().hash(github) ^
      const DeepCollectionEquality().hash(instagram) ^
      const DeepCollectionEquality().hash(facebook);

  @JsonKey(ignore: true)
  @override
  _$MetadataCopyWith<_Metadata> get copyWith =>
      __$MetadataCopyWithImpl<_Metadata>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MetadataToJson(this);
  }
}

abstract class _Metadata implements Metadata {
  const factory _Metadata(
      {String? address,
      String? kind,
      String? owner,
      String? alias,
      String? description,
      String? logo,
      String? site,
      String? support,
      String? email,
      String? twitter,
      String? telegram,
      String? discord,
      String? reddit,
      String? slack,
      String? riot,
      String? github,
      String? instagram,
      String? facebook}) = _$_Metadata;

  factory _Metadata.fromJson(Map<String, dynamic> json) = _$_Metadata.fromJson;

  @override
  String? get address => throw _privateConstructorUsedError;
  @override
  String? get kind => throw _privateConstructorUsedError;
  @override
  String? get owner => throw _privateConstructorUsedError;
  @override
  String? get alias => throw _privateConstructorUsedError;
  @override
  String? get description => throw _privateConstructorUsedError;
  @override
  String? get logo => throw _privateConstructorUsedError;
  @override
  String? get site => throw _privateConstructorUsedError;
  @override
  String? get support => throw _privateConstructorUsedError;
  @override
  String? get email => throw _privateConstructorUsedError;
  @override
  String? get twitter => throw _privateConstructorUsedError;
  @override
  String? get telegram => throw _privateConstructorUsedError;
  @override
  String? get discord => throw _privateConstructorUsedError;
  @override
  String? get reddit => throw _privateConstructorUsedError;
  @override
  String? get slack => throw _privateConstructorUsedError;
  @override
  String? get riot => throw _privateConstructorUsedError;
  @override
  String? get github => throw _privateConstructorUsedError;
  @override
  String? get instagram => throw _privateConstructorUsedError;
  @override
  String? get facebook => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$MetadataCopyWith<_Metadata> get copyWith =>
      throw _privateConstructorUsedError;
}

Sender _$SenderFromJson(Map<String, dynamic> json) {
  return _Sender.fromJson(json);
}

/// @nodoc
class _$SenderTearOff {
  const _$SenderTearOff();

  _Sender call({required String address}) {
    return _Sender(
      address: address,
    );
  }

  Sender fromJson(Map<String, Object> json) {
    return Sender.fromJson(json);
  }
}

/// @nodoc
const $Sender = _$SenderTearOff();

/// @nodoc
mixin _$Sender {
  String get address => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SenderCopyWith<Sender> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SenderCopyWith<$Res> {
  factory $SenderCopyWith(Sender value, $Res Function(Sender) then) =
      _$SenderCopyWithImpl<$Res>;
  $Res call({String address});
}

/// @nodoc
class _$SenderCopyWithImpl<$Res> implements $SenderCopyWith<$Res> {
  _$SenderCopyWithImpl(this._value, this._then);

  final Sender _value;
  // ignore: unused_field
  final $Res Function(Sender) _then;

  @override
  $Res call({
    Object? address = freezed,
  }) {
    return _then(_value.copyWith(
      address: address == freezed
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$SenderCopyWith<$Res> implements $SenderCopyWith<$Res> {
  factory _$SenderCopyWith(_Sender value, $Res Function(_Sender) then) =
      __$SenderCopyWithImpl<$Res>;
  @override
  $Res call({String address});
}

/// @nodoc
class __$SenderCopyWithImpl<$Res> extends _$SenderCopyWithImpl<$Res>
    implements _$SenderCopyWith<$Res> {
  __$SenderCopyWithImpl(_Sender _value, $Res Function(_Sender) _then)
      : super(_value, (v) => _then(v as _Sender));

  @override
  _Sender get _value => super._value as _Sender;

  @override
  $Res call({
    Object? address = freezed,
  }) {
    return _then(_Sender(
      address: address == freezed
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Sender implements _Sender {
  const _$_Sender({required this.address});

  factory _$_Sender.fromJson(Map<String, dynamic> json) =>
      _$$_SenderFromJson(json);

  @override
  final String address;

  @override
  String toString() {
    return 'Sender(address: $address)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Sender &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(address);

  @JsonKey(ignore: true)
  @override
  _$SenderCopyWith<_Sender> get copyWith =>
      __$SenderCopyWithImpl<_Sender>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SenderToJson(this);
  }
}

abstract class _Sender implements Sender {
  const factory _Sender({required String address}) = _$_Sender;

  factory _Sender.fromJson(Map<String, dynamic> json) = _$_Sender.fromJson;

  @override
  String get address => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SenderCopyWith<_Sender> get copyWith => throw _privateConstructorUsedError;
}

Target _$TargetFromJson(Map<String, dynamic> json) {
  return _Target.fromJson(json);
}

/// @nodoc
class _$TargetTearOff {
  const _$TargetTearOff();

  _Target call({required String alias, required String address}) {
    return _Target(
      alias: alias,
      address: address,
    );
  }

  Target fromJson(Map<String, Object> json) {
    return Target.fromJson(json);
  }
}

/// @nodoc
const $Target = _$TargetTearOff();

/// @nodoc
mixin _$Target {
  String get alias => throw _privateConstructorUsedError;
  String get address => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TargetCopyWith<Target> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TargetCopyWith<$Res> {
  factory $TargetCopyWith(Target value, $Res Function(Target) then) =
      _$TargetCopyWithImpl<$Res>;
  $Res call({String alias, String address});
}

/// @nodoc
class _$TargetCopyWithImpl<$Res> implements $TargetCopyWith<$Res> {
  _$TargetCopyWithImpl(this._value, this._then);

  final Target _value;
  // ignore: unused_field
  final $Res Function(Target) _then;

  @override
  $Res call({
    Object? alias = freezed,
    Object? address = freezed,
  }) {
    return _then(_value.copyWith(
      alias: alias == freezed
          ? _value.alias
          : alias // ignore: cast_nullable_to_non_nullable
              as String,
      address: address == freezed
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$TargetCopyWith<$Res> implements $TargetCopyWith<$Res> {
  factory _$TargetCopyWith(_Target value, $Res Function(_Target) then) =
      __$TargetCopyWithImpl<$Res>;
  @override
  $Res call({String alias, String address});
}

/// @nodoc
class __$TargetCopyWithImpl<$Res> extends _$TargetCopyWithImpl<$Res>
    implements _$TargetCopyWith<$Res> {
  __$TargetCopyWithImpl(_Target _value, $Res Function(_Target) _then)
      : super(_value, (v) => _then(v as _Target));

  @override
  _Target get _value => super._value as _Target;

  @override
  $Res call({
    Object? alias = freezed,
    Object? address = freezed,
  }) {
    return _then(_Target(
      alias: alias == freezed
          ? _value.alias
          : alias // ignore: cast_nullable_to_non_nullable
              as String,
      address: address == freezed
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Target implements _Target {
  const _$_Target({required this.alias, required this.address});

  factory _$_Target.fromJson(Map<String, dynamic> json) =>
      _$$_TargetFromJson(json);

  @override
  final String alias;
  @override
  final String address;

  @override
  String toString() {
    return 'Target(alias: $alias, address: $address)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Target &&
            (identical(other.alias, alias) ||
                const DeepCollectionEquality().equals(other.alias, alias)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(alias) ^
      const DeepCollectionEquality().hash(address);

  @JsonKey(ignore: true)
  @override
  _$TargetCopyWith<_Target> get copyWith =>
      __$TargetCopyWithImpl<_Target>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TargetToJson(this);
  }
}

abstract class _Target implements Target {
  const factory _Target({required String alias, required String address}) =
      _$_Target;

  factory _Target.fromJson(Map<String, dynamic> json) = _$_Target.fromJson;

  @override
  String get alias => throw _privateConstructorUsedError;
  @override
  String get address => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$TargetCopyWith<_Target> get copyWith => throw _privateConstructorUsedError;
}

Parameter _$ParameterFromJson(Map<String, dynamic> json) {
  return _Parameter.fromJson(json);
}

/// @nodoc
class _$ParameterTearOff {
  const _$ParameterTearOff();

  _Parameter call({required String entrypoint, required Value value}) {
    return _Parameter(
      entrypoint: entrypoint,
      value: value,
    );
  }

  Parameter fromJson(Map<String, Object> json) {
    return Parameter.fromJson(json);
  }
}

/// @nodoc
const $Parameter = _$ParameterTearOff();

/// @nodoc
mixin _$Parameter {
  String get entrypoint => throw _privateConstructorUsedError;
  Value get value => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ParameterCopyWith<Parameter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ParameterCopyWith<$Res> {
  factory $ParameterCopyWith(Parameter value, $Res Function(Parameter) then) =
      _$ParameterCopyWithImpl<$Res>;
  $Res call({String entrypoint, Value value});

  $ValueCopyWith<$Res> get value;
}

/// @nodoc
class _$ParameterCopyWithImpl<$Res> implements $ParameterCopyWith<$Res> {
  _$ParameterCopyWithImpl(this._value, this._then);

  final Parameter _value;
  // ignore: unused_field
  final $Res Function(Parameter) _then;

  @override
  $Res call({
    Object? entrypoint = freezed,
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      entrypoint: entrypoint == freezed
          ? _value.entrypoint
          : entrypoint // ignore: cast_nullable_to_non_nullable
              as String,
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Value,
    ));
  }

  @override
  $ValueCopyWith<$Res> get value {
    return $ValueCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
abstract class _$ParameterCopyWith<$Res> implements $ParameterCopyWith<$Res> {
  factory _$ParameterCopyWith(
          _Parameter value, $Res Function(_Parameter) then) =
      __$ParameterCopyWithImpl<$Res>;
  @override
  $Res call({String entrypoint, Value value});

  @override
  $ValueCopyWith<$Res> get value;
}

/// @nodoc
class __$ParameterCopyWithImpl<$Res> extends _$ParameterCopyWithImpl<$Res>
    implements _$ParameterCopyWith<$Res> {
  __$ParameterCopyWithImpl(_Parameter _value, $Res Function(_Parameter) _then)
      : super(_value, (v) => _then(v as _Parameter));

  @override
  _Parameter get _value => super._value as _Parameter;

  @override
  $Res call({
    Object? entrypoint = freezed,
    Object? value = freezed,
  }) {
    return _then(_Parameter(
      entrypoint: entrypoint == freezed
          ? _value.entrypoint
          : entrypoint // ignore: cast_nullable_to_non_nullable
              as String,
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Value,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Parameter implements _Parameter {
  const _$_Parameter({required this.entrypoint, required this.value});

  factory _$_Parameter.fromJson(Map<String, dynamic> json) =>
      _$$_ParameterFromJson(json);

  @override
  final String entrypoint;
  @override
  final Value value;

  @override
  String toString() {
    return 'Parameter(entrypoint: $entrypoint, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Parameter &&
            (identical(other.entrypoint, entrypoint) ||
                const DeepCollectionEquality()
                    .equals(other.entrypoint, entrypoint)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(entrypoint) ^
      const DeepCollectionEquality().hash(value);

  @JsonKey(ignore: true)
  @override
  _$ParameterCopyWith<_Parameter> get copyWith =>
      __$ParameterCopyWithImpl<_Parameter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ParameterToJson(this);
  }
}

abstract class _Parameter implements Parameter {
  const factory _Parameter({required String entrypoint, required Value value}) =
      _$_Parameter;

  factory _Parameter.fromJson(Map<String, dynamic> json) =
      _$_Parameter.fromJson;

  @override
  String get entrypoint => throw _privateConstructorUsedError;
  @override
  Value get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$ParameterCopyWith<_Parameter> get copyWith =>
      throw _privateConstructorUsedError;
}

Value _$ValueFromJson(Map<String, dynamic> json) {
  return _Value.fromJson(json);
}

/// @nodoc
class _$ValueTearOff {
  const _$ValueTearOff();

  _Value call({@JsonKey(name: 'R') String? r}) {
    return _Value(
      r: r,
    );
  }

  Value fromJson(Map<String, Object> json) {
    return Value.fromJson(json);
  }
}

/// @nodoc
const $Value = _$ValueTearOff();

/// @nodoc
mixin _$Value {
  @JsonKey(name: 'R')
  String? get r => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ValueCopyWith<Value> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValueCopyWith<$Res> {
  factory $ValueCopyWith(Value value, $Res Function(Value) then) =
      _$ValueCopyWithImpl<$Res>;
  $Res call({@JsonKey(name: 'R') String? r});
}

/// @nodoc
class _$ValueCopyWithImpl<$Res> implements $ValueCopyWith<$Res> {
  _$ValueCopyWithImpl(this._value, this._then);

  final Value _value;
  // ignore: unused_field
  final $Res Function(Value) _then;

  @override
  $Res call({
    Object? r = freezed,
  }) {
    return _then(_value.copyWith(
      r: r == freezed
          ? _value.r
          : r // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$ValueCopyWith<$Res> implements $ValueCopyWith<$Res> {
  factory _$ValueCopyWith(_Value value, $Res Function(_Value) then) =
      __$ValueCopyWithImpl<$Res>;
  @override
  $Res call({@JsonKey(name: 'R') String? r});
}

/// @nodoc
class __$ValueCopyWithImpl<$Res> extends _$ValueCopyWithImpl<$Res>
    implements _$ValueCopyWith<$Res> {
  __$ValueCopyWithImpl(_Value _value, $Res Function(_Value) _then)
      : super(_value, (v) => _then(v as _Value));

  @override
  _Value get _value => super._value as _Value;

  @override
  $Res call({
    Object? r = freezed,
  }) {
    return _then(_Value(
      r: r == freezed
          ? _value.r
          : r // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Value implements _Value {
  const _$_Value({@JsonKey(name: 'R') this.r});

  factory _$_Value.fromJson(Map<String, dynamic> json) =>
      _$$_ValueFromJson(json);

  @override
  @JsonKey(name: 'R')
  final String? r;

  @override
  String toString() {
    return 'Value(r: $r)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Value &&
            (identical(other.r, r) ||
                const DeepCollectionEquality().equals(other.r, r)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(r);

  @JsonKey(ignore: true)
  @override
  _$ValueCopyWith<_Value> get copyWith =>
      __$ValueCopyWithImpl<_Value>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ValueToJson(this);
  }
}

abstract class _Value implements Value {
  const factory _Value({@JsonKey(name: 'R') String? r}) = _$_Value;

  factory _Value.fromJson(Map<String, dynamic> json) = _$_Value.fromJson;

  @override
  @JsonKey(name: 'R')
  String? get r => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$ValueCopyWith<_Value> get copyWith => throw _privateConstructorUsedError;
}
